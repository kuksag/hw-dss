# Представители в сравнении

В сравнении участвовали следующие функции:
* `MurmurHash3_x64_128`
* `XXH128`
* `memcpy` (для наглядного сравнения)

Выбор представителей именно такой, чтобы обеспечить одинаковую длину результата (128 бит), 
а также потому что тестирование производилось на компьютерах с 64-битной системой (оба на дистрибутиве Ubunutu)

# Алгоритм сравнения 
Бенчмарк устроен просто: перебираем ключ от нижней до большей границы; никаких случайных запусков или прогрева кеша не производилось.
Все собираем с ключом `-O2` и прагмой `#pragma GCC target ("avx2")` (хочется верить, что это позволяет программе воспользоваться SIMD. 


# Результат

## Малые тесты
Разберем случай, когда хэшируем ключ до 100 байт:

![](https://github.com/kuksag/hw-dss/blob/master/hw-01/plots/ubuntu_results_small.png)

* Можем наблюдать скачки как у `murmur` так и у `xxh`. Предположение из-за чего так: ключ разбивается на бакеты, каждый новый скачок -- новый бакет. 
* Также можем видеть аномалию у `murmur` в районе 75-80 байт, такая же аномалия встретилась на [другой машине](https://github.com/kuksag/hw-dss/blob/master/hw-01/plots/results_small.png).
* Видим сильное преобладание `memcpy` перед другими функциями

## Крупные тесты

Размер ключа от 100 до 1000 байт:

![](https://github.com/kuksag/hw-dss/blob/master/hw-01/plots/ubuntu_results_big.png)

* Сперва видим, что `xxh` вообще растет сублинейно
* Однако быстрее `memcpy` ничего себя не показало, что не сходится с результатами [`xxh`](https://github.com/Cyan4973/xxHash#benchmarks)

Почему `xxh` оказался асимптотически быстрее линии: предположений нет; <br>
Почему появилось расхождение с результатами другого бенчмарка: либо оптимизатор соптимизировал не то, что нужно; либо программы не смогли воспользоваться SIMD
